/*
Vortex by Vortex Group is licensed under a Creative Commons Reconocimiento 3.0 Unported License.
To view a copy of this licence, visit: http://creativecommons.org/licenses/by/3.0/
Project URL: https://sourceforge.net/p/vortexnet
*/
if(typeof(require) != "undefined"){
    var http = require("http");
	//var request = require('request');
}

var NodoClienteHTTPNode = function (p) {    
	console.log("inicializando cliente http");
    this.url = p.url;
    this.port = p.port||80;
    this.intervalo_polling = p.intervalo_polling  || 1500;
    this.verbose = p.verbose || false;
    this.mensajes_por_paquete = p.mensajes_por_paquete || 100;
    this.alDesconectar = p.alDesconectar || function(){};
    this.start();
};

NodoClienteHTTPNode.prototype.start = function () {
    this.intervaloPedidoIdSesion = 5000;
    this.bandejaSalida = [];
    //arranca con un receptor que no hace nada
    this.receptor = {
        recibirMensaje: function (un_mensaje) { }
    };

    //pido sesiï¿½n
    this.pedirIdSesion();
};

NodoClienteHTTPNode.prototype.pedirIdSesion = function() {
    var _this = this;
	console.log("pidiendo sesion");
	var req = http.request({
		host: _this.url,
		path: '/create',
		method: 'POST',
		port: _this.port
	}, function (res) {
		var response_data = "";
		res.on('data', function (data) {
			response_data += new Buffer(data).toString();
		})
		res.on('end', function (data) {
			if(isNaN(parseInt(response_data))) {
				console.log("errorAlPedirSesion");
				setTimeout(function () { _this.pedirIdSesion(); }, _this.intervaloPedidoIdSesion);
				return;
			}
			_this.idSesion = response_data;
            if (_this.verbose) console.log("idSesion: " + _this.idSesion);
            setTimeout(function(){_this.enviarYRecibirMensajes();}, _this.intervaloPolling);
		})
	}).on('error', function (e) {
		console.log("errorAlPedirSesion: " + e.message);
		setTimeout(function () { _this.pedirIdSesion(); }, _this.intervaloPedidoIdSesion);
	});
	
	req.end();
};

NodoClienteHTTPNode.prototype.enviarYRecibirMensajes = function () {
    var _this = this;
    var cant_mensajes_a_enviar;
    var bandejaSalidaAux = [];

    cant_mensajes_a_enviar = this.bandejaSalida.length;
    if (cant_mensajes_a_enviar >= this.mensajes_por_paquete) cant_mensajes_a_enviar = this.mensajes_por_paquete;

    bandejaSalidaAux = this.bandejaSalida.splice(0, cant_mensajes_a_enviar);

    var post_data = JSON.stringify({
		mensajes_vortex: JSON.stringify({
			"contenidos": bandejaSalidaAux,
			"proximaEsperaMinima": 0,
			"proximaEsperaMaxima": 300000
		})
	});
	
    if (bandejaSalidaAux.length > 0) {
        if (_this.verbose) console.log("enviando:", bandejaSalidaAux);
    }

	var req = http.request({
		host: _this.url,
		path: '/session/' + _this.idSesion,
		method: 'POST',
		port: _this.port//,
//		headers: {
//			'Content-Length': Buffer.byteLength(post_data)
//		}
	}, function (res) {
		var response_data = "";
		res.on('data', function (data) {
			response_data = response_data + new Buffer(data).toString();
		});
		res.on('end', function (data) {
			var mensajesRecibidos = "";
			try{
				mensajesRecibidos = JSON.parse(response_data).contenidos;
				mensajesRecibidos.forEach(function (element, index, array) {
					if (_this.verbose) console.log("mensaje recibido:", element);
					_this.receptor.recibirMensaje(element);
				});
			}catch(ex){
				console.log("error Al Parsear Mensajes:", error);
			}
			setTimeout(function () {
                _this.enviarYRecibirMensajes();
            }, _this.intervaloPolling);
		});
	}).on('error', function (e) {
		console.log("error Al Enviar Mensajes:", error);
		_this.bandejaSalida = bandejaSalidaAux.concat(_this.bandejaSalida);
		setTimeout(function () {
			_this.enviarYRecibirMensajes();
		}, _this.intervaloPolling);
	});
	
	req.write(post_data);
	
	req.end();
	
};

NodoClienteHTTPNode.prototype.recibirMensaje = function (un_mensaje) {
    this.bandejaSalida.push(un_mensaje);
};

NodoClienteHTTPNode.prototype.conectarCon = function (un_receptor) {
    this.receptor = un_receptor;
};

NodoClienteHTTPNode.prototype.desconectarDe = function(un_nodo){
    this.receptor = {
        recibirMensaje:function(){},
        desconectarDe: function(){}
    };
    this.desconectarDe = function(){};
    
    un_nodo.desconectarDe(this);
    if(this.verbose) console.log('socket ' + this.id + ' desconectado');
    this.alDesconectar();
};
if(typeof(require) != "undefined"){
    exports.clase = NodoClienteHTTPNode;
}